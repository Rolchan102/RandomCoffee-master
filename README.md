# Info
Тестовый бот: рассылает раз в день сообщения со стихами пользователям. Позволяет получать рандомные стихи. Позволяет сохранять в избранное и просматривать избранное.

Используемый стек: Django, Celery, Redis, PostgreSQL.

# Установка
Установите все требования:
pip install -r requirements.txt

Проект настроен для деплоя через Dokku. Берем VPS, ставим dokku, создаем приложение там, postgres, redis, git.
Создаем необходимые переменные окружения:

BUILDPACK_URL:            https://github.com/heroku/heroku-buildpack-python.git#v191

DISABLE_COLLECTSTATIC:    1

DJANGO_DEBUG:             False

DOKKU_LETSENCRYPT_EMAIL:  email@gmail.com

MEDIA_DOMAIN:             https://my_site.com

WEB_DOMAIN:               https://my_site.com

TELEGRAM_TOKEN:           tg_token_from_bot_father

Говорит TG, что будем webhook-ом работать через запрос: 

https://api.telegram.org/bot[ТУТ_ТОКЕН]/setWebhook?url=[ТУТ_URL_WEBHOOK]/super_secter_webhook/

Пушим проект в dokku и готово. Детальнее тут: https://github.com/ohld/django-telegram-bot/wiki/Production-Deployment-using-Dokku

# Структура проекта
.env файлик содержит в себе переменные окружения, которые нужны нам для локальной разработки.
При деплое на прод мы единожды при развертывании приложения пропишем несколько переменных окружения на сервере и более про это забудем.

Dockerfile — докерфайл проекта, базовые директива для докера, применяться будет только для локальной разработки.

docker-compose.yml — тут описаны сервисы, которые будут подняты в контейнерах докером на локальной машине.
По умолчанию это: db (PostgreSQL), redis, web, bot, celery, celery-beat (последние два нужны для периодических задач, которые, возможно, понадобится выполять нашему боту).

entrypoint.sh — последний файлик для локальной работы проекта, говорит докеру, что делать после того как поднимутся все контейнеры.
Тут говорим, что надо сделать миграции, создать админа по кредам из .env файла, прогрузить различного рода фикстуры, если таковые имеются в проекте, собрать статику и запустить сервер.

Procfile — данный файл необходим для Dokku при деплое на прод.
Он содержит одну или более строк описывающих типы процессов и ассоциированных им команд.
При деплое приложения в Dokku будет создан Docker образ, затем Dokku извлечет файл Procfile и команды, которые в нем описаны, будут переданы в docker run.
В нашем случае мы говорим, что необходимо сделать миграции, поднять gunicorn сервер, запустить celery воркера и celery beat.

requirements.txt — тут все понятно, список зависимостей нашего бота, которые будут ставится как при развертывании на локальной машине, так и при деплое на продашкн.

run_pooling.py — для кейса, когда приложение работает в pooling режиме (на локальном ПК).

runtime.txt — говорит Dokku, какую версию Python мы хотим использовать.

staticfiles — в данной папке вся статика проекта (админка).

media — по умолчанию используем данную папку для хранения медиа файлов.
Предположим, мы из админки закачиваем какие-то картинки, которые надо будет показывать пользователям,
вот они падают в данную папку потому, что в settings.py проекта прописано: MEDIA_ROOT = os.path.join(BASE_DIR, ‘media’)

logs — очень важная папка, потому что по логам мы будем отлавливать все, что происходит с ботом.
В settings.py у нас задан логгер по умолчанию, который будет писать в файлик main.log все, что надо, ротируя его каждые 5 Мб.

dtb — головная папка Django проекта.

tgbot — вся бизнес-логика бота находится в данной папке:

tgbot/admin.py — регистрирует модели приложения для использования в админке.

tgbot/forms.py — кастомная форма для массовой рассылки сообщений из админки.

tgbot/models.py — содержит все модели, используемые ботом. Как минимум для базовой работы необходимы модели:

Config — для задания различных параметров бота в формате “параметр” — “значение”;
User — для пользователей бота;
Location, Arcgis — для работы с геокодированием, если будет надо боту;
UserActionLog — фиксация действий пользователя.

tgbot/tasks.py — celery задачи, которые можно устанавливать на исполнение по расписанию
в очень удобной форме в админке проекта благодаря django-celery-beat.

tgbot/utils.p — различные функции-хелперы.

tgbot/fixtures — здесь могут быть различные фикстуры с данными для моделей проекта.

tgbot/migrations — тут все понятно, миграции проекта.

tgbot/templates — кастомные шаблоны для админки.

tgbot/handlers/admin.py — модуль-обработчик событий для пользователей с правами администратора.
Наша модель пользователей, описанная в модуле tgbot/models.py содержит возможность задавать различные права пользователям.
Так вот, если пользователь — администратор, то можно описать для него тот или иной функционал,
который будет реализовываться при вызове им команд бота. Логика как раз описывается в данном модуле.

tgbot/handlers/files.py — модуль-обработчик событий, связанных с отправкой боту файлов.
Опять же, по-умолчанию, заточен на администраторов.
Когда мы посылаем какой-нибудь файл боту (фото, видео, документ и пр) — файл сохраняется и ему присваивается уникальные ID.
В последующем, если мы хотим отослать файл пользователю, можно в соответствующий API метод передавать полный URL до этого файла (например, на внешнем хранилище),
а можно передать просто Telegram ID этого файла. Вот как раз тут описана функция, которая возвращает ID файла отосланного боту, если его отослал пользователь с правами администратора.

tgbot/handlers/handlers.py — головной модуль-обработчик всех пользовательских событий, которые могут возникнуть у пользователей в процессе взаимодействия с ботом.
Логика большинства функций довольно простая: прилетает в метод два параметра — update и context, из которых можно извлечь все: id чата, информацию о пользователе, что отослано и т.п.
Далее происходит та или иная бизнес-логика, после чего, либо вызывается api метод edit_message, либо send_message, либо какая-то другая отправка, либо ничего, в зависимости от нужд логики.

tgbot/handlers/utils.py — функции-хелперы для работы обработчиков.
Базовый набор: функция отсылки пользователя действия “печатаю”, декоратор для логирования и обертка над api методом send_message с обработками исключений.

tgbot/handlers/commands.py — модуль-обработчик для команд бота.
Чтобы не смешивать обычные обработчики действий (нажатия на кнопки, отправки сообщений, документов и пр) и обработчики команд — выносим их в отдельным модуль.

tgbot/handlers/keyboard_utils.py — модуль содержит функции генерации клавиатур.
В огромном количестве случаев боту необходимо посылать пользователю сообщения вместе с клавиатурами, чтобы пользователь выбирал те или иные действия.
Безусловно, можно все генерировать на месте, внутри модуля handlers.py (к примеру), но логичнее все вынести в единый модуль, отвечающий только за клавиатуры.

tgbot/handlers/manage_data.py — в данном модуле определяются переменные для параметра callback_data, задаваемого при использовании клавиатуры.
Т.е. в keyboard_utils модуле мы создаем клавиатуры, которые состоят из кнопок, а у кнопок есть два главных параметра: текст и обратный вызов,
т.е. какая строка будет отправлена боту, когда пользователь нажмет на кнопку.

tgbot/handlers/static_text.py — в данный модуль выносим все текстовые данные, которые используем в боте.

tgbot/handlers/dispatcher.py — наконец, пожалуй, ключевой модуль бота, в нем, в соответствии с названием,
происходит диспетчеризация всех процессов бота. Во-первых, он содержит функцию запуска pooling-а для тестовых сред.
Во-вторых, что самое главное, он содержит функцию setup_dispatcher, главная задача которой связать события,
которые вызывает пользователь (например, вызов команды — CommandHandler, отправка сообщения — MessageHandler,
нажатие на кнопку — CallbackQueryHandler и т.п.) с функционалом, который необходимо выполнить боту по данном событию.

# Изучение кода
Разворачивая проект в Docker-е на локальной машине, не забывайте, что после того как внесли правки в код, необходимо перезагрузить контейнер с ботом.
Т.е. вы делаете: docker-compose up -d — build — в результате поднимутся все контейнеры.

Далее просматриваете их:
docker ps -a
И, найдя в списке контейнер с ботом пишите (когда это необходимо):
docker restart XXX , где XXX — ID контейнера.
Соответственно, если вы изменяете Celery-задачи, то не забывает перезагружать контейнер соответствующий для тестирования.
